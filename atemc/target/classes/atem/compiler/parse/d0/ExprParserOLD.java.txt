package atem.compiler.parse;

import atem.compiler.ast.callables.JCLambda;
import atem.compiler.lex.Token;
import atem.compiler.lex.TokenKind;
import atem.compiler.ast.*;
import atem.compiler.utils.Debuger;

import java.util.ArrayList;
import java.util.Stack;

import static atem.compiler.lex.TokenKind.*;
import static atem.compiler.lex.TokenKind.RBRACKET;

public class ExprParser {
    Parser parser;
    public ExprParser(Parser parser)
    {
        this.parser = parser;
    }

    Stack<JCExpression> stack = new Stack<>();

    JCExpression parse()
    {
        stack.clear();
        Token posToken= parser.token;

        while (true)
        {
            TokenKind kind= parser.kind;
            if(kind==EOF
                    || kind == RBRACKET
                    || kind == RBRACE
                    || kind == RPAREN
                    || kind == SEMI
                    || kind == COMMA
                //  || kind == COLON
            )
                break;
            JCExpression expression = parseItem();
            if(expression==null)
                break;
            stack.push(expression);
        }

        if(stack.size()==1)
            return stack.pop();
        else   if(stack.size()==0)
            return null;
        else
            return parser.maker.at(posToken).ProcCallExpr(stack);
    }

    JCExpression parseItem()
    {
        switch (parser.kind)
        {
            case VAR:
                return variableDecl();
            case LBRACKET:
                return JCArrayLiteral();
            case LPAREN:
                return parenExpr();
            case LBRACE:
                return braceExpr();
            case DOT:
                return fieldAccess();
            //case THIS:
            case IDENTIFIER:
                return parseIdent();
            case INTLITERAL: case FLOATLITERAL:
            case STRINGLITERAL:
            case TRUE:
            case FALSE:
                return literal();
            case GT:case GTEQ:case LT:case LTEQ:case EQEQ:case NOTEQ:
            case ADD:case SUB:case MUL:case DIV:
            return   binaryExpr();
            case COLON:
                return   colonExpr();
            case EQ:
                return assignExpr();
            default:
                return null;
        }
    }

    /** 分析赋值表达式 */
    JCAssign assignExpr()
    {
        JCExpression leftExpr = pop();
        parser. nextToken();
        JCExpression right = parseSubExpression() ;
        return parser.maker.at(leftExpr.posToken).Assign(leftExpr, right);
    }

    JCExpression binaryExpr() {
        Token posToken = parser.token;
        parser.nextToken();
        JCExpression rightExpr =parseItem();// parseSubExpression();
        JCExpression expr = pop();
        //Debuger.outln("104 expr: " + expr+   "     rightExpr: "  +rightExpr  );
        if (expr == null)
            expr = parser.maker.at(posToken).Unary(posToken.kind, expr);
        else
        {
            expr =  moutExpr( expr ,rightExpr , posToken.kind );
        }

        //Debuger.outln("109 binaryExpr:" + expr );
        return expr;
    }

    JCExpression moutExpr(JCExpression left,JCExpression right,TokenKind kind )
    {
        if(left instanceof JCBinary)
        {
            JCBinary leftBin= (JCBinary) left;
            var priority1= getOpPriority(leftBin.opcode);
            int priority2= getOpPriority(kind);
            if(priority1==priority2)
            {
                return parser.maker.at(left.posToken).Binary(kind, left, right);
            }
            else  if(priority1<priority2)
            {
                JCExpression leftRight = leftBin.right;
                JCExpression newRight =  moutExpr(leftRight,right,kind );
                leftBin.right  = newRight;
                return left;
            }
            else
            {
                return parser.maker.at(left.posToken).Binary(kind, left, right);
            }
        }
        else {
            return parser.maker.at(left.posToken).Binary(kind, left, right);
        }
    }

    int getOpPriority(TokenKind kind)
    {
        switch (kind)
        {
            case GT:case GTEQ:case LT:case LTEQ:case EQEQ:case NOTEQ:
            return 1;
            case ADD:case SUB:
            return 2;
            case MUL:case DIV:
            return 3;
            default:
                return -1;
        }
    }

    JCExpression colonExpr()
    {
        Token posToken = parser.token;
        parser.nextToken();
        JCExpression rightExpr = parseSubExpression();
        JCExpression expr = pop();
        if(expr==null)
            expr =parser. maker.at(posToken).Colon(expr,rightExpr);
        else
            expr =parser. maker.at(expr.posToken).Colon(expr,rightExpr);
        return expr;
    }

    /** 分析常量表达式
     * Literal =
     *     INTLITERAL
     *   | STRINGLITERAL
     *   | TRUE
     *   | FALSE
     */
    JCExpression literal( ) {
        Object value = ParseUtil. parseTokenKindValue(parser);
        JCLiteral literal = parser.maker.at(parser.token).Literal(value);
        parser.nextToken();
        return literal;
    }

    /* 分析标识符 */
    JCIdent parseIdent()
    {
        /* 记录开始位置词法标记 */
        Token posToken = parser. token;
        if ( parser. kind == IDENTIFIER) {
            parser. nextToken();
            /* 用posToken创建标识符表达式 */
            JCIdent jcIdent = parser. maker.at(posToken).Ident(posToken);
            return jcIdent;
        }
       /* else if ( parser. kind == THIS) {
            parser. nextToken();
            JCIdent jcIdent = parser. maker.at(posToken).Ident(posToken);
            jcIdent.isThis = true;
            return jcIdent;
        }*/
        else
        {
            /* 错误处理 */
            parser.  log.error(posToken,"期望标识符");
            return null;
        }
    }

    JCExpression fieldAccess(  ) {
        Token posToken = parser.token;
        JCExpression expr = pop();
        if(parser.kind ==DOT)
        {
            parser.nextToken();
            if(parser.kind==LPAREN)
            {
                ParenExpr args = parenExpr();
                if (expr == null)
                    return args;
                else
                    expr = parser.maker.at(expr.posToken).Apply(expr, args.items);
            }
            else {
                Token nameToken = parser.parseNameToken();// String name = parseName();
                if (expr == null)
                    expr = parser.maker.at(posToken).FieldAccess(expr, nameToken);
                else
                    expr = parser.maker.at(expr.posToken).FieldAccess(expr, nameToken);
            }
        }
        return expr;
    }

    JCExpression pop()
    {
        if(stack.size()>0)
            return stack.pop();
        return null;
    }

    /** 分析变量声明语句 */
    JCVariableDecl variableDecl() {
        Token posToken = parser.token;
        parser.nextToken();
        JCIdent name = parseIdent();
        JCVariableDecl statement = variableDecl(name,posToken);
        return statement;
    }

    JCVariableDecl variableDecl(  JCIdent name,Token posToken)
    {
        JCExpression init = null;
        if (parser.kind == TokenKind.EQ) //如果是'=',变量有初始值
        {
            parser. nextToken();
            init = parseSubExpression();
        }
        JCVariableDecl result = parser.maker.at(posToken).VarDef(name, init,true);
        return result;
    }

    JCExpression parseSubExpression()
    {
        ExprParser parser1 = new ExprParser(this.parser);
        return parser1.parse();
    }

    ArrayLiteral JCArrayLiteral()
    {
        Token posToken =  parser.token;
        parser.accept(LBRACKET);
        ArrayList<JCExpression> args =  parseExprs(RBRACKET);
        parser.accept(RBRACKET);
        ArrayLiteral JCArrayLiteral =  parser.maker.at(posToken).JCArrayLiteral(   args);
        return JCArrayLiteral;
    }

    ParenExpr parenExpr() {
        Token posToken = parser.token;
        parser.accept(LPAREN);
        ArrayList<JCExpression> args = parseExprs(RPAREN);
        parser.accept(RPAREN);

        ParenExpr parenExpr = parser.maker.at(posToken).parenExpr(args);
        return parenExpr;

        /*
        JCExpression expr = pop();

        if (expr == null) {
            ParenExpr parenExpr = parser.maker.at(posToken).parenExpr(args);
            return parenExpr;
        } else {
            JCMethodInvocation mi = parser. maker.at(posToken).Apply( expr , TreeMaker.toExprArray(args) );
            return mi;
        }*/
    }

    JCExpression braceExpr() {
        Token posToken = parser.token;
        parser.accept(LBRACE);
        ArrayList<JCTree> args =new ArrayList<>();
        TokenKind kind =  parseBraceExprs(args);
        parser.accept(RBRACE);
        if(args.size()>0 && args.get(0) instanceof JCPair)
        {
            var JCDynamicLiteral = parser.maker.at(posToken).JCDynamicLiteral(kind, args);
            return JCDynamicLiteral;
        }
        else {
            JCLambda JCLambda = parser.maker.at(posToken).lambda(kind, args);
            return JCLambda;
        }
    }

    ArrayList<JCExpression> parseExprs(TokenKind endKind)
    {
        ArrayList<JCExpression> args = new ArrayList<>();

        if ( parser.kind != endKind) {
            JCExpression argExpr =   parseSubExpression();
            if (argExpr != null)
                args.add(argExpr);
            while ( parser.kind == COMMA) {
                Token commaToken =  parser.token;
                parser.nextToken();
                argExpr =  parseSubExpression();
                if (argExpr != null)
                    args.add(argExpr);
                else
                    parser.error(commaToken,"多余的逗号");
            }
        }
        return args;
    }

    TokenKind parseBraceExprs( ArrayList<JCTree> args)
    {
        TokenKind kind = NONE;
        boolean first =true;
        while (true)
        {
            BraceItem braceItem = parseBraceExprItem();
            if(braceItem.argExpr!=null)
                args.add(braceItem.argExpr);
            else {
                TokenKind curkind = parser.kind;
                if(curkind==RBRACE
                        || curkind==EOF
                )
                    break;
                parser.error(parser.token, "多余的分割符号");
                parser.nextToken();
            }
            if(first)
            {
                if(braceItem.argExpr instanceof JCStatement)
                {
                    kind = SEMI;
                    first =false;
                }
                else {
                    kind = braceItem.endKind;
                    first = false;
                }
            }
            TokenKind curkind = parser.kind;
            if(curkind==RBRACE
                    || curkind==EOF
            )
                break;
        }
       /* if ( parser.kind != RBRACE) {
            JCExpression argExpr = parseSubExpression();
            if (argExpr != null)
                args.add(argExpr);

            if (parser.kind == COMMA || parser.kind == SEMI) {
                kind = parser.kind;
                parser.nextToken();
            }
            else {
                while (true) {
                    posToken = parser.token;
                    argExpr = parseSubExpression();
                    if (argExpr != null)
                        parser.error(parser.token, "多余的分割符号");
                    if (parser.kind == COMMA) {
                        args.add(argExpr);
                        parser.nextToken();
                    } else if (parser.kind == SEMI) {
                        JCExprStatement statement = parser.maker.at(posToken).Exec(argExpr);
                        args.add(statement);
                        parser.nextToken();
                    } else {
                        args.add(argExpr);
                        break;
                    }
                }
            }
        }*/
        return kind;
    }

    BraceItem parseBraceExprItem()
    {
        Token posToken = parser.token;
      /*  if(
                posToken.kind.equals( IDENTIFIER) ==true
                && posToken.identName.equals("println") ==true
        )
        {
            Debuger.outln("376 parseBraceExprItem:" + posToken);
            //Debuger.outln("382 parseBraceExprItem:" + posToken.kind.equals( IDENTIFIER)  + ":" +  posToken.identName.equals("println"));
        }*/
        BraceItem braceItem = new BraceItem();
        JCExpression expression = parseSubExpression();
        if(expression!=null) {
            if (parser.kind == COMMA) {
                braceItem.argExpr = expression;
                braceItem.endKind = parser.kind;
                parser.nextToken();
            } else if (parser.kind == SEMI) {
                braceItem.argExpr = parser.maker.at(posToken).Exec(expression);
                braceItem.endKind = parser.kind;
                parser.nextToken();
            } else {
                braceItem.argExpr = expression;
            }
        }
        else
        {
            if(parser.kind==RBRACE)
            {
                return braceItem;
            }
            else
            {
                JCStatement statement = parser.parseStatement();
                braceItem.argExpr = statement;
            }
        }
        return braceItem;
    }

    class BraceItem
    {
        JCTree argExpr;
        TokenKind endKind = NONE;
    }
}
